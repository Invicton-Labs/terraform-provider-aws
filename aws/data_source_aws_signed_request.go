package aws

import (
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"io/ioutil"
	"mime"
	"net/http"
	"net/url"
	"reflect"
	"strconv"
	"strings"
	"time"
	"unicode/utf8"
	"unsafe"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/client"
	v4 "github.com/aws/aws-sdk-go/aws/signer/v4"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func dataSourceAwsSignedRequest() *schema.Resource {
	return &schema.Resource{
		Read: dataSourceSignedRequestRead,

		Schema: map[string]*schema.Schema{
			"method": {
				Description:  "The HTTP method to use for the request.",
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validateHTTPMethod(),
			},

			"service": {
				Description: "The name of the AWS service to target for the request, as specified in the endpoint for the service (e.g. 'ec2' in 'ec2.amazonaws.com').",
				Type:        schema.TypeString,
				Required:    true,
			},

			"host": {
				Description:  "The specific host endpoint to make the request against (overrides the default endpoint for the specified service).",
				Type:         schema.TypeString,
				Optional:     true,
				Computed:     true,
				ValidateFunc: validateUrlHostOnly,
			},

			"path": {
				Description:  "The URL path (not including the host) to make the request against.",
				Type:         schema.TypeString,
				Optional:     true,
				Default:      "",
				ValidateFunc: validateUrlPathOnly,
			},

			"query_parameters": {
				Description: "Query parameters to include in the request.",
				Type:        schema.TypeMap,
				Optional:    true,
				Default:     map[string]string{},
				Elem: &schema.Schema{
					Type:     schema.TypeString,
					Required: true,
				},
			},

			"request_headers": {
				Description: "Headers to include in the request. Certain headers that are automatically generated for signing will override provided headers with the same key.",
				Type:        schema.TypeMap,
				Optional:    true,
				Default:     map[string]string{},
				Elem: &schema.Schema{
					Type:     schema.TypeString,
					Required: true,
				},
			},

			"request_body": {
				Description: "The body content to send in the request.",
				Type:        schema.TypeString,
				Optional:    true,
			},

			// Response values
			"response_status_code": {
				Description: "The HTTP code of the response status.",
				Type:        schema.TypeInt,
				Computed:    true,
			},

			"response_status": {
				Description: "The response status string.",
				Type:        schema.TypeString,
				Computed:    true,
			},

			"response_headers": {
				Description: "A map of response headers. If multiple headers with the same key were returned, only the first is included here.",
				Computed:    true,
				Type:        schema.TypeMap,
				Elem: &schema.Schema{
					Type: schema.TypeString,
				},
			},

			"request_id": {
				Description: "The AWS request ID, if one was returned in the response.",
				Computed:    true,
				Type:        schema.TypeString,
			},

			"response_body_base64": {
				Description: "The response body, base64-encoded.",
				Computed:    true,
				Type:        schema.TypeString,
			},

			"response_body": {
				Description: "The response body without encoding. This field will only be set if the response body consists entirely of valid UTF-8 characters.",
				Computed:    true,
				Type:        schema.TypeString,
			},

			"response_body_json": {
				Description: "The response body, converted to JSON format. This field will only be set if the response's `Content-Type` header is `text/xml` or `application/json`.",
				Computed:    true,
				Type:        schema.TypeString,
			},

			"response_mediatype": {
				Description: "The mediatype (e.g. `application/json`) that was returned in the response's `Content-Type` header, excluding any parameters (e.g. with `charset=utf-8` removed, if it was in the header).",
				Computed:    true,
				Type:        schema.TypeString,
			},

			"response_mediatype_parameters": {
				Description: "A map of parameters that were included in the response's `Content-Type` header (e.g. `{\"charset\": \"utf-8\"}`).",
				Computed:    true,
				Type:        schema.TypeString,
			},
		},
	}
}

var dataSourceSignedRequestFilteredParameters = []string{
	// These are the headers generated by signing. They cannot be specified in advance.
	"X-Amz-Security-Token",
	"X-Amz-Date",
	"Authorization",
	"X-Amz-Algorithm",
	"X-Amz-Credential",
	"X-Amz-SignedHeaders",
	"X-Amz-Signature",
	// Created on the fly, cannot be specified in advance
	"Content-Length",
}
var dataSourceSignedRequestClientType = reflect.TypeOf((*client.Client)(nil))

func signedRequestGetServiceClients(awsClient *AWSClient) (serviceClientsByServiceName map[string]*client.Client, serviceClientsBySigningName map[string]*client.Client) {
	serviceClientsByServiceName = map[string]*client.Client{}
	serviceClientsBySigningName = map[string]*client.Client{}
	// Look up the endpoint for the service
	configValue := reflect.ValueOf(awsClient).Elem()
	// For each service field
	for i := 0; i < configValue.NumField(); i++ {
		configField := configValue.Field(i)
		if configField.Kind() == reflect.Ptr {
			configField = configField.Elem()
			// If it's a struct, evaluate it further
			if configField.Kind() == reflect.Struct {
				for j := 0; j < configField.NumField(); j++ {
					// Check each field in the struct
					innerField := configField.Field(j)
					// If it's a client type, we know we've found a client field
					if innerField.Type() == dataSourceSignedRequestClientType {
						// Assert the inner field as a *client.Client
						client := reflect.NewAt(innerField.Type(), unsafe.Pointer(innerField.UnsafeAddr())).Elem().Interface().(*client.Client)
						serviceClientsByServiceName[client.ServiceName] = client
						serviceClientsBySigningName[client.SigningName] = client
					}
					// The client has been extracted, so we can skip the remaining fields
					break
				}
			}
		}
	}
	return
}

func signedRequestGetServiceClientByName(awsClient *AWSClient, serviceName string) *client.Client {
	serviceClientsByServiceName, serviceClientsBySigningName := signedRequestGetServiceClients(awsClient)
	if client, ok := serviceClientsByServiceName[serviceName]; ok {
		return client
	}
	if client, ok := serviceClientsBySigningName[serviceName]; ok {
		return client
	}
	return nil
}

func signedRequestCreate(awsClient *AWSClient, serviceName string, host *string, path string, method string, queryParameters url.Values, headers map[string][]string, requestBody *string) (request *http.Request, err error) {
	serviceClient := signedRequestGetServiceClientByName(awsClient, serviceName)
	if serviceClient == nil {
		return nil, fmt.Errorf("Unknown AWS service '%s'", serviceName)
	}

	req := &http.Request{
		Method: method,
	}

	reqUrl, err := url.Parse(serviceClient.ClientInfo.Endpoint)
	if err != nil {
		return nil, fmt.Errorf("Failed to parse default host endpoint (%s): %s", serviceClient.ClientInfo.Endpoint, err.Error())
	}
	if host != nil {
		reqUrl, err = url.Parse(*host)
		if err != nil {
			return nil, fmt.Errorf("Failed to parse host: %s", err.Error())
		}
		// Override things that shouldn't be in the host URL
		reqUrl.Scheme = "https"
		reqUrl.Opaque = ""
		reqUrl.User = nil
		reqUrl.Path = ""
		reqUrl.RawPath = ""
		reqUrl.ForceQuery = false
		reqUrl.RawQuery = ""
		reqUrl.Fragment = ""
		reqUrl.RawFragment = ""
	}

	pathUrl, err := url.Parse(path)
	if err != nil {
		return nil, fmt.Errorf("Failed to parse path: %s", err.Error())
	}
	reqUrl.Path = pathUrl.Path
	reqUrl.RawPath = pathUrl.RawPath

	if queryParameters != nil {
		for key := range queryParameters {
			for _, filteredParam := range dataSourceSignedRequestFilteredParameters {
				if strings.ToLower(key) == strings.ToLower(filteredParam) {
					delete(queryParameters, key)
				}
			}
		}
		reqUrl.RawQuery = queryParameters.Encode()
	}

	req.URL = reqUrl

	if headers != nil {
		for key := range headers {
			for _, filteredHeader := range dataSourceSignedRequestFilteredParameters {
				if strings.ToLower(key) == strings.ToLower(filteredHeader) {
					delete(headers, key)
				}
			}
		}
		req.Header = headers
	} else {
		req.Header = http.Header{}
	}

	var bodyReader *strings.Reader
	var hasBody bool
	if requestBody != nil {
		bodyReader = strings.NewReader(*requestBody)
		req.Body = ioutil.NopCloser(bodyReader)
		req.ContentLength = int64(len(*requestBody))
		req.Header.Set("Content-Length", fmt.Sprintf("%q", req.ContentLength))
		hasBody = true
	}

	signer := v4.NewSigner(awsClient.stsconn.Config.Credentials)
	if hasBody {
		if _, err := signer.Sign(req, bodyReader, serviceClient.ClientInfo.SigningName, serviceClient.ClientInfo.SigningRegion, time.Now()); err != nil {
			return nil, fmt.Errorf("Failed to sign request: %s", err.Error())
		}
	} else {
		if _, err := signer.Sign(req, nil, serviceClient.ClientInfo.SigningName, serviceClient.ClientInfo.SigningRegion, time.Now()); err != nil {
			return nil, fmt.Errorf("Failed to sign request: %s", err.Error())
		}
	}

	return req, nil
}

type signedRequestResponse struct {
	Host            string
	Status          string
	StatusCode      int
	Headers         map[string]string
	RequestId       *string
	BodyBase64      *string
	BodyRaw         *string
	BodyJson        *string
	Mediatype       *string
	MediatypeParams map[string]string
}

func signedRequestDo(req *http.Request) (*signedRequestResponse, error) {
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}

	sResp := &signedRequestResponse{
		Host:       fmt.Sprintf("%s://%s", req.URL.Scheme, req.URL.Host),
		Status:     resp.Status,
		StatusCode: resp.StatusCode,
	}

	responseHeaders := map[string]string{}
	for k, v := range resp.Header {
		if len(v) > 0 {
			responseHeaders[k] = v[0]
		}
	}
	sResp.Headers = responseHeaders

	if resp.Body != nil {
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}
		sResp.BodyBase64 = aws.String(base64.StdEncoding.EncodeToString(body))

		// If it's valid UTF-8, provide the raw body
		if utf8.Valid(body) {
			sResp.BodyRaw = aws.String(string(body))
		}

		// If a Content-Type header is provided, see if we can use it to unmarshal the content
		if contentType, ok := responseHeaders["Content-Type"]; ok {
			mediatype, params, err := mime.ParseMediaType(contentType)
			// Only proceed with unmarshalling if the content type could be parsed
			if err == nil {
				sResp.Mediatype = &mediatype
				sResp.MediatypeParams = params

				switch mediatype {
				case "text/xml":
					// If it's XML, parse it and convert it back to JSON
					unmarshalledResponse := map[string]interface{}{}
					if err := xml.Unmarshal(body, &unmarshalledResponse); err == nil {
						jsonBody, err := json.Marshal(unmarshalledResponse)
						if err == nil {
							sResp.BodyJson = aws.String(string(jsonBody))
						}
					} else {
						fmt.Println(err)
					}
				case "application/json":
					// If it's JSON, parse it and convert it back to JSON (so the output is the same each time, regardless of whether the input ordering of map elements changes)
					unmarshalledResponse := map[string]interface{}{}
					if err := json.Unmarshal(body, &unmarshalledResponse); err == nil {
						jsonBody, err := json.Marshal(unmarshalledResponse)
						if err == nil {
							sResp.BodyJson = aws.String(string(jsonBody))
						}
					} else {
						fmt.Println(err)
					}
				}
			}
		}
	}

	if requestId, ok := responseHeaders["X-Amzn-Requestid"]; ok {
		sResp.RequestId = &requestId
	}

	return sResp, nil
}

func dataSourceSignedRequestRead(d *schema.ResourceData, meta interface{}) error {
	serviceName := d.Get("service").(string)
	var host *string
	if v, ok := d.GetOk("host"); ok {
		host = aws.String(v.(string))
	}
	var requestBody *string
	if v, ok := d.GetOk("request_body"); ok {
		requestBody = aws.String(v.(string))
	}
	queryParams := map[string][]string{}
	for key, value := range d.Get("query_parameters").(map[string]interface{}) {
		queryParams[key] = []string{value.(string)}
	}
	headers := map[string][]string{}
	for key, value := range d.Get("request_headers").(map[string]interface{}) {
		headers[key] = []string{value.(string)}
	}
	req, err := signedRequestCreate(meta.(*AWSClient), serviceName, host, d.Get("path").(string), d.Get("method").(string), queryParams, headers, requestBody)
	if err != nil {
		return err
	}

	sResp, err := signedRequestDo(req)
	if err != nil {
		return err
	}

	if err := d.Set("host", sResp.Host); err != nil {
		return err
	}
	if err := d.Set("response_status_code", sResp.StatusCode); err != nil {
		return err
	}
	if err := d.Set("response_status", sResp.Status); err != nil {
		return err
	}
	if err := d.Set("response_headers", sResp.Headers); err != nil {
		return err
	}
	if sResp.BodyBase64 != nil {
		if err := d.Set("response_body_base64", sResp.BodyBase64); err != nil {
			return err
		}
	}
	if sResp.BodyRaw != nil {
		if err := d.Set("response_body", sResp.BodyRaw); err != nil {
			return err
		}
	}
	if sResp.BodyJson != nil {
		if err := d.Set("response_body_json", sResp.BodyJson); err != nil {
			return err
		}
	}
	if sResp.RequestId != nil {
		if err := d.Set("request_id", sResp.RequestId); err != nil {
			return err
		}
	}
	if sResp.Mediatype != nil {
		if err := d.Set("response_mediatype", sResp.Mediatype); err != nil {
			return err
		}
	}
	if sResp.MediatypeParams != nil {
		if err := d.Set("response_mediatype_parameters", sResp.MediatypeParams); err != nil {
			return err
		}
	}

	if sResp.RequestId != nil {
		d.SetId(*sResp.RequestId)
		if err := d.Set("request_id", sResp.RequestId); err != nil {
			return err
		}
	} else {
		// Set a unique ID so it runs each time
		d.SetId(strconv.FormatInt(time.Now().Unix(), 10))
	}

	return nil
}
